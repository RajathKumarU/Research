An Empirical Study of Cryptographic Misuse
in Android Applications
 titlerp
Developers use cryptographic APIs in Android with the intent
of securing data such as passwords and personal information
on mobile devices. In this paper, we ask whether developers
use the cryptographic APIs in a fashion that provides typical
cryptographic notions of security, e.g., IND-CPA security. We
develop program analysis techniques to automatically check
programs on the Google Play marketplace, and find that
10,327 out of 11,748 applications that use cryptographic APIs
– 88% overall – make at least one mistake. These numbers
show that applications do not use cryptographic APIs in a
fashion that maximizes overall security. We then suggest
specific remediations based on our analysis towards improving
overall cryptographic security in Android applications.

abstractrp
Software Security, Program Analysis
keywordsrp
Developers use cryptographic primitives like block ciphers
and message authenticate codes (MACs) to secure data and
communications. Cryptographers know there is a right way
and a wrong way to use these primitives, where the right
way provides strong security guarantees and the wrong way
invariably leads to trouble.
In this paper, we ask whether developers know how to use
cryptographic APIs in a cryptographically correct fashion.
In particular, given code that type-checks and compiles, does
the implemented code use cryptographic primitives correctly
to achieve typical definitions of security? We assume that
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are not
made or distributed for profit or commercial advantage and that copies bear
this notice and the full citation on the first page. Copyrights for components
of this work owned by others than ACM must be honored. Abstracting with
credit is permitted. To copy otherwise, or republish, to post on servers or to
redistribute to lists, requires prior specific permission and/or a fee. Request
permissions from permissions@acm.org.
CCS’13, November 04 - 08 2013, Berlin, Germany
Copyright 2013 ACM 978-1-4503-2477-9/13/11 $15.00
http://dx.doi.org/10.1145/2508859.2516693.
developers who use cryptography in their applications make
this choice consciously. After all, a developer would not likely
try to encrypt or authenticate data that they did not believe
needed securing.
We focus on two well-known security standards: security
against chosen plaintext attacks (IND-CPA) and cracking
resistance. For each definition of security, there is a generally
accepted right and wrong way to do things. For example,
electronic code book (ECB) mode should only be used by
cryptographic experts. This is because identical plaintext
blocks encrypt to identical ciphertext blocks, thus rendering
ECB non-IND-CPA secure. When creating a password hash,
a unique salt should be chosen to make password cracking
more computationally expensive.
We focus on the Android platform, which is attractive
for three reasons. First, Android applications run on smart
phones, and smart phones manage a tremendous amount of
personal information such as passwords, location, and social
network data. Second, Android is closely related to Java, and
Java’s cryptographic API is stable. For example, the Cipher
API which provides access to various encryption schemes has
been unmodified since Java 1.4 was released in 2002. Third,
the large number of available Android applications allows
us to perform our analysis on a large dataset, thus gaining
insight into how application developers use cryptographic
primitives.
One approach for checking cryptographic implementations
would be to adapt verification-based tools like the Microsoft
Crypto Verification Kit [7], Mur? [22], and others. The
main advantage of verification-based approaches is that they
provide strong guarantees. However, they are also heavyweight,
require significant expertise, and require manual
effort. The sum of these three limitations make the tools
inappropriate for large-scale experiments, or for use by dayto-day
developers who are not cryptographers.
Instead, we adopt a light-weight static analysis approach
that checks for common flaws. Our tool, called CryptoLint,
is based upon the Androguard Android program analysis
framework [12]. The main new idea in CryptoLint is to
use static program slicing to identify flows between cryptographic
keys, initialization vectors, and similar cryptographic
material and the cryptographic operations themselves. CryptoLint
takes a raw Android binary, disassembles it, and
checks for typical cryptographic misuses quickly and accurately.
These characteristics make CryptoLint appropriate
for use by developers, app store operators, and securityconscious
users.
Using CryptoLint, we performed a study on crypto-
graphic implementations in 11,748 Android applications.
Overall we find that 10,327 programs – 88% in total – use
cryptography inappropriately. The raw scale of misuse indicates
a widespread misunderstanding of how to properly use
cryptography in Android development.
We find there are exacerbating factors, and suggest remediations.
First, while current developer tools can check a
number of security properties, using cryptography correctly
is not one of them. Adding light-weight checks, such as
in CryptoLint, would improve security. Second, implementations
abstract away semantic assumptions about the
correct use of cryptographic primitives. For example, the
documentation for CBC encryption does not state that the
initialization vector should not be a constant. Adding a security
discussion to cryptographic API documentation would
address this problem. Third, the default behavior in cryptographic
libraries is often not a recommended practice. For
example, the predominant Android Java security provider
API defaults to using the ECB block cipher mode for AES
encryption. To remedy this problem, we suggest changing
the default behavior to a more secure variant.
Contributions: Overall, our contributions are:
• We propose light-weight static analysis techniques and
tools that can catch common cryptographic misuses
(§5). Application developers and app store maintainers
can use the tools to identify likely misuses in cryptography
before an end-user uses the application.
• We perform a large-scale experiment to measure cryptographic
misuse in Android (§6). To the best of our
knowledge, we are the first to perform such a study at
scale, demonstrate a widespread problem, and identify
the likely culprits.
• We suggest remediation measures to help address the
widespread issues identified (§7).

 introductionrp
CryptoLint checks real-world Android applications for the
violation of the six security rules outlined in Section 3. With
this automated approach we identified 10,327 applications
(88% of our dataset) that violate at least one of these rules.
We identified one of the contributing factors to be the undocumented
insecure default configuration of the BouncyCastle
cryptographic security provider used on the Android platform.
Based on the insights we gained from the large-scale
analysis of real-world Android applications, we also illustrated
different mitigation approaches, we believe would be
beneficial to the overall security of the Android ecosystem.
We are currently working on making CryptoLint a publicly
accessible online service where developers and curious
users can submit Android applications and have them
evaluated with respect to the cryptographic security rules
described herein. In the future we also plan to extend CryptoLint
with security rules that capture the misuse of asymmetric
cryptography.

 conclusionrp
[1] The legion of the bouncy castle. http://bouncycastle.
org/, 2013.
[2] M. Abadi and B. Warinschi. Password-Based Encryption
Analyzed. In Proceedings of the international colloquium
of Automata, Languages and Programming, pages 664–
676. Springer, 2005.
[3] I. Apple. iOS Security Contents, 2012.
[4] M. Bellare, T. Kohno, and C. Namprempre. Authenticated
encryption in SSH: Provably Fixing the SSH
Binary Packet Protocol. In Proceedings of the 9th ACM
conference on Computer and communications security,
pages 1–11, 2002.
[5] M. Bellare, T. Ristenpart, and S. Tessaro. Multi-instance
Security and Its Application to Password-Based Cryptography.
In Proceedings of the 32nd Annual Cryptology
Conference, pages 312–329. Springer, 2012.
[6] M. Bellare and P. Rogaway. Course notes for introduction
to modern cryptography. cseweb.ucsd.edu/users/
mihir/cse207/classnotes.html.
[7] K. Bhargavan, C. Fournet, R. Corin, and E. Zalinescu.
Cryptographically verified implementations for TLS. In
Proceedings of the 15th ACM conference on computer
and Communications security, pages 459–468, 2008.
[8] H. Chen and D. Wagner. MOPS: An Infrastructure
for Examining Security Properties of Software. In Proceedings
of the 9th ACM conference on Computer and
communications security, pages 235–244, 2002.
[9] S. Clark and T. Goodspeed. Why (special agent) Johnny
(still) can’t encrypt: a security analysis of the APCO
project 25 two-way radio system. In Proceedings of the
20th USENIX Security Symposium, 2011.
[10] R. Cytron, J. Ferrante, B. K. Rosen, M. N. Wegman,
and F. K. Zadeck. Efficiently Computing Static Single
Assignment Form and the Control Dependence Graph.
ACM Transactions on Programming Languages and Systems,
13(4):451–490, Oct. 1991.
[11] J. Dean, D. Grove, and C. Chambers. Optimization
of object-oriented programs using static class hierarchy
analysis. In Proceedings of the 9th European Conference
on Object-Oriented Programming, pages 77–101.
Springer, 1995.
[12] A. Desnos. Androguard: Reverse engineering, malware
and goodware analysis of android applications
... and more (ninja !). http://code.google.com/p/
androguard/.
[13] W. Enck, P. Gilbert, B.-G. Chun, L. P. Cox, J. Jung,
P. McDaniel, and A. N. Sheth. TaintDroid: an
information-flow tracking system for realtime privacy
monitoring on smartphones. In Proceedings of the 9th
USENIX Symposium on Operating Systems Design and
Implementation, 2010.
[14] W. Enck, M. Ongtang, and P. McDaniel. On lightweight
mobile phone application certification. In Proceedings
of the 16th ACM conference on computer and Communications
security, pages 235–245, 2009.
[15] S. Fahl, M. Harbach, T. Muders, M. Smith, L. Baumg¨artner,
and B. Freisleben. Why Eve and Mallory Love
Android: An Analysis of Android SSL (In)Security. In
Proceedings of the 19th ACM conference on Computer
and communications security, pages 50–61, 2012.
[16] A. P. Felt, E. Chin, S. Hanna, D. Song, and D. Wagner.
Android permissions demystified. In Proceedings of the
18th ACM conference on Computer and communications
security, pages 627–638, 2011.
[17] J. Hoffmann, M. Ussath, T. Holz, and M. Spreitzenbarth.
Slicing droids: program slicing for smali code. In In
Proceedings of the 28th ACM Symposium on Applied
Computing, 2013.
[18] S. C. Johnson. Lint , a C Program Checker. Technical
report, 1978.
[19] B. Kaliski. PKCS #5: Password-based cryptography
specification version 2.0. http://tools.ietf.org/
html/rfc2898.
[20] A. Klyubin. Some SecureRandom thoughts.
http://android-developers.blogspot.co.uk/2013/
08/some-securerandom-thoughts.html, 2013.
[21] D. Larochelle and D. Evans. Statically Detecting Likely
Buffer Overflow Vulnerabilities. In Proceedings of the
10th USENIX Security Symposium, pages 177–190, 2001.
[22] J. C. Mitchell, M. Mitchell, and U. Stern. Automated
Analysis of Cryptographic Protocols Using Murphi. In
Proceedings of the IEEE Symposium on Security and
Privacy, pages 141–151, 1997.
[23] B. Moeller. TLS insecurity (attack on CBC). http:
//www.openssl.org/~bodo/tls-cbc.txt, 2001.
[24] M. Nauman, S. Khan, and X. Zhang. Apex: extending
android permission model and enforcement with
user-defined runtime constraints. In Proceedings of the
5th ACM Symposium on Information, Computer and
Communications Security, pages 328–332, 2010.
[25] P. Pearce, A. P. Felt, G. Nunez, and D. Wagner. AdDroid:
Privilege separation for applications and advertisers
in android. In Proceedings of the 7th ACM Symposium
on Information, Computer and Communications
Security, 2012.
[26] T. Vidas, D. Votipka, and N. Christin. All Your Droid
Are Belong To Us: A Survey of Current Android Attacks.
In Proceedings of the 5th USENIX Workshop on
Offensive Technologies, 2011.
[27] M. Weiser. Program Slicing. In Proceedings of the 5th
international conference on Software engineering, pages
439–449, 1981.
[28] A. Whitten and J. Tygar. Why Johnny Can’t Encrypt :
A Usability Evaluation of PGP 5.0. In Proceedings of
the 8th USENIX Security Symposium, 1999.
[29] Y. Zhou, Z. Wang, W. Zhou, and X. Jiang. Hey, you,
get off of my market: Detecting malicious apps in official
and alternative android markets. In Proceedings of the
19th Annual Network and Distributed System Security
Symposium, 2012.
referencesrp